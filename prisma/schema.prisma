// Optimized PostgreSQL schema for Subscription Sharing Platform
// Uses Supabase PostgreSQL - sync users with Supabase Auth via supabaseId

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id         String   @id @default(cuid())
  supabaseId String   @unique
  email      String   @unique
  name       String?
  avatarUrl  String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  ownedSubscriptions Subscription[]
  memberships        SubscriptionMember[]
  reviewsGiven       Review[]
  transactionsPaid  Transaction[] @relation("TransactionPayer")
  transactionsReceived Transaction[] @relation("TransactionPayee")

  @@index([email])
  @@index([supabaseId])
  @@index([createdAt])
}

model Subscription {
  id            String   @id @default(cuid())
  ownerId       String
  serviceName   String
  serviceType   String?
  totalSlots    Int
  availableSlots Int
  pricePerSlot Decimal  @db.Decimal(10, 2)
  monthlyPrice  Decimal  @db.Decimal(10, 2)
  currency      String   @default("USD")
  billingCycle  String   @default("monthly")
  status        String   @default("active")
  description   String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  owner      User       @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  members    SubscriptionMember[]
  reviews    Review[]
  transactions Transaction[]

  @@index([ownerId])
  @@index([serviceName])
  @@index([status])
  @@index([createdAt])
  @@index([serviceName, status])
}

model SubscriptionMember {
  id        String   @id @default(cuid())
  subscriptionId String
  userId    String
  role      String   @default("member")
  status    String   @default("active")
  joinedAt  DateTime @default(now())
  leftAt    DateTime?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  subscription Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([subscriptionId, userId])
  @@index([subscriptionId])
  @@index([userId])
  @@index([status])
}

model Review {
  id        String   @id @default(cuid())
  subscriptionId String
  userId    String
  score     Int
  comment   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  subscription Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([subscriptionId, userId])
  @@index([subscriptionId])
  @@index([userId])
  @@index([score])
  @@index([createdAt])
}

model Transaction {
  id            String   @id @default(cuid())
  subscriptionId String
  payerId      String
  payeeId      String
  amount       Decimal  @db.Decimal(10, 2)
  currency     String   @default("USD")
  status       String   @default("pending")
  paymentMethod String?
  externalId   String?
  metadata     Json?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  subscription Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  payer        User          @relation("TransactionPayer", fields: [payerId], references: [id], onDelete: Restrict)
  payee        User          @relation("TransactionPayee", fields: [payeeId], references: [id], onDelete: Restrict)

  @@index([externalId])
  @@index([subscriptionId])
  @@index([payerId])
  @@index([payeeId])
  @@index([status])
  @@index([createdAt])
  @@index([subscriptionId, status])
}
